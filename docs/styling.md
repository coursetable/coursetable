# Styling

On CourseTable, we have the following infrastructure related to styling:

- React Bootstrap
- CSS modules

**We only use these two.** Please refrain from bringing in other styling frameworks/libraries, because they unnecessarily bloat the bundle size.

In general, you should prefer to use plain CSS modules where possible. React Bootstrap is nice because it provides a lot of pre-built components. As a spillover benefit, the Bootstrap utility classes (such as `p-3 m-3`) are also available and you may use them if you like.

Below are some tricks for working with plain CSS modules.

## Creating CSS modules

Our convention is always to create a file next to the component file—for example, for `About.tsx`, you would create an `About.module.css` file. Then, you can import the CSS file like so:

```tsx
import styles from './About.module.css';
```

`styles` is an object that maps from declared class names to their generated names. For example, if you have a CSS file like this:

```css
.container {
  padding: 1rem;
}
```

Then, you can use `styles.container` as a class name in your JSX:

```tsx
<div className={styles.container}>...</div>
```

The advantage of this is that you can have multiple CSS files with the same class names, and they will not conflict, because each generated class name will be hashed.

If you want to compose this class with other classes, you can use `clsx`:

```tsx
import clsx from 'clsx';

<div className={clsx(styles.container, 'p-3')}>...</div>;
```

**Only class names, and all class names, are hashed by default.** This means if you have an ID selector like `#container`, it will not be hashed and will be global. If you want to target global classes, such as those generated by React Bootstrap, you can use the `:global` pseudo-selector:

```css
.container :global(.active) {
  padding: 1rem;
}
```

Avoid using non-module class names in your own CSS files. Only use `:global` to target class names from other libraries. Preferably, all selectors in your module CSS should _start_ with a scoped class name, so it's safe to remove them when the respective element is removed, without worrying about breaking other elements.

Module class names should be camelCased, not kebab-cased, so that you can easily refer to them using dot notation.

If you want to apply a lot of styles to a library-provided component, and this change is safe to be done globally, you can consider creating a global stylesheet.

```css
.some-class {
  /* ... */
}

.some-other-class {
  /* ... */
}
```

- If this targeted component is only used in one place: put the stylesheet next to the component and call it `some-library-override.css`. Import it as `import './some-library-override.css';`. This makes sure that this CSS never loads unless the component is used, thanks to our CSS code splitting.
- If this targeted component is used in multiple places: put the selectors in `src/index.css`. This makes sure that this CSS always loads. Otherwise you have to import it in every file that uses the component (given the way CSS side effects work).

## CSS variables

To achieve a consistent design system, common values such as colors and font sizes are defined as CSS variables in `src/index.css`. You can use them like so:

```css
.container {
  background-color: var(--color-bg);
}
```

There are still a lot of hard-coded values in the codebase. Try to extract them to variables where you can.

## Dark mode

To create different styles for dark mode, use the following selector:

```css
[data-theme='dark'] .container {
  background-color: white;
}
```

Because of the extra selector, this rule will always override the default rule with only a `.container` selector.

All pre-defined CSS variables already come with dark mode support.

You should generally be able to achieve dark mode support with CSS only (because you only need to change the colors). In the rare occasion that you need to change the markup (for example, to use a different image source), you can use the `useTheme` hook:

```tsx
import { useTheme } from 'path/to/src/contexts/themeContext';

// ...
const { theme } = useTheme();
const element = (
  <img
    src={
      theme === 'dark' ? '/path/to/dark/image.png' : '/path/to/light/image.png'
    }
    alt="..."
  />
);
```

## Responsive styles

To create different styles for different screen sizes, use the `@media` query:

```css
@media (max-width: 767px) {
  .container {
    padding: 1rem;
  }
}
```

This will only apply to screens that are mobile size.

```css
@media (min-width: 1200px) {
  .container {
    padding: 1rem;
  }
}
```

This will only apply to screens that are desktop size.

Tip: if your component is only rendered on tablet size and above, you can use `@media (max-width: 1199px)` to select _just_ tablets, without needing an extra `(min-width: 768px)`.

Unfortunately due to our lack of CSS preprocessors, we cannot use variables in media queries. You can refer to the following table:

| Size          | Min width | Max width |
| ------------- | --------- | --------- |
| Small mobile  | 0         | 479px     |
| Large mobile  | 480px     | 767px     |
| Tablet        | 768px     | 1199px    |
| Small desktop | 1200px    | 1319px    |
| Large desktop | 1320px    | ∞         |

Try to keep your responsive design in CSS only, by using the same DOM structure and changing how they are layed out. If you need to change the markup (for example, to render a component only on large screens), you can use the `useWindowDimensions` hook:

```tsx
import { useWindowDimensions } from 'path/to/src/contexts/useWindowDimensions';

// ...
const { isMobile } = useWindowDimensions();
const element = isMobile ? <MobileComponent /> : <DesktopComponent />;
```

## Conditional styling

If you need to conditionally apply a style, use the following syntax:

```tsx
<div
  className={clsx(
    styles.container,
    isMobile && styles.mobileContainer,
    hasData ? styles.containerWithData : styles.containerWithoutData,
  )}
>
  ...
</div>
```

This works best with boolean logic. If for some reason you need to dynamically generate a dimension or a color, you can use the `style` prop, but try to avoid it if you can.

```tsx
<div
  className={styles.container}
  style={{
    backgroundColor: chroma(baseColor).darken(0.5).css(),
  }}
>
  ...
</div>
```

Or, in the rarest occasion where you need to dynamically generate a style but `style` cannot work:

```tsx
<div
  className={styles.container}
  style={{
    // @ts-expect-error: custom CSS variable
    '--hover-color': chroma(baseColor).darken(0.5).css(),
  }}
>
  ...
</div>
```

```css
.container:hover {
  background-color: var(--hover-color);
}
```
