import clsx from 'clsx';
import styles from './releases.module.css';
import { TextComponent } from '../../components/Typography';

<div className={clsx(styles.container, 'mx-auto')}>
<TextComponent type="secondary">

# Introducing Quist, a new query language for CourseTable

_2024-02-23_

Hi everyone!

We have just released a new feature that we are very excited about: [Quist](https://github.com/coursetable/quist), a new query language for CourseTable. The goal of Quist is to provide a more powerful and flexible way to filter and search for classes on CourseTable. We believe that Quist will enable a lot of advanced use cases that are otherwise difficult to express with purely graphical interfaces.

Let's start by looking at an example.

```
(subject:in MATH, CPSC, S&DS OR description:contains Python) AND 300<=number<500 AND NOT professor-names:has-any-of "Bruce Wayne", "Tony Stark"
```

Let's break it in parts:

- `subject:in MATH, CPSC, S&DS` means that the class must be in one of the specified subjects.
- `description:contains Python` means that the class description mentions "Python".
- `300<=number<500` means that the class number must be between 300 and 499.
- `NOT professor-names:has-any-of "Bruce Wayne", "Tony Stark"` means that the class must not be taught by either of the specified professors.

This query will return all classes that are in MATH, CPSC, or S&DS, or otherwise has something to do with Python, have a number between 300 and 499, and are not taught by Bruce Wayne or Tony Stark.

Previously, this is not achievableâ€”you cannot specify what kind of text you are searching for, you cannot search professor names with exact strings, and you cannot join the results with another separate condition.

Let's explore what exactly you can do with Quist.

## Syntax

At the highest level, you write a query like this:

```
query1 OR query2 OR query3
```

This query will return the union of the results of `query1`, `query2`, and `query3`.

AND is the default operator, so you can also write:

```
query1 query2 query3
query1 AND query2 AND query3
```

Which both return the intersection of the results of `query1`, `query2`, and `query3`.

Note that you can only use one type of operator in one level. In the following:

```
query1 OR query2 AND query3
```

`OR` is used as the operator, and `AND` is simply treated as plain text!

To mix `AND` and `OR`, you can use parentheses:

```
query1 OR (query2 AND query3)
```

`NOT` is also supported. You can prefix any query with `NOT` to negate it:

```
NOT query1 OR NOT query2

# Equivalent to:
NOT (query1 AND query2)
```

### Data types

To discuss queries, we first need to talk about data types. Quist supports the following JSON data types:

- Categorical: typically a string with a fixed set of values.
- Numerical: a number.
- Boolean: `true` or `false`.
- Text: arbitrary string.
- Set: an array of categorical values.

In the context of CourseTable, here are all fields that we support:

- Categorical: `school`, `season`, `type`, `subject`
- Numerical: `rating`, `workload`, `professor-rating`, `number`, `enrollment`, `credits`
- Boolean: `cancelled`, `conflicting`, `grad`, `discussion`, `fysem`, `colsem`
- Set: `skills`, `areas`, `days`, `info-attributes`, `subjects`, `professor-names`
- Text: `title`, `description`, `location`

Each type corresponds to its own set of operators. If during parsing, we encounter an operator on a field that's not of the right type, we stop treating it as an operator and treat it as plain text instead!

### Querying categorical fields

All `value` below should be string literals. In Quist, a string is either space-delimited, or double quoted. For example, `days:has Monday` and `professor-names:has "Jay Lim"` are both valid.

- `field:is value`: the field is exactly `value`.
  - This is like `field = value`.
- `field:in value1, value2, ..., valueN`: the field is one of the values. We end looking for values when a value is followed by another string without a comma in between.
  - This is like `field IN (value1, value2, ..., valueN)`.

### Querying numerical fields

Querying numerical fields is the most different because you use mathematical expressions. All `num` below should be number literals.

- `field < num`: the field is less than `num`.
- `field <= num`: the field is less than or equal to `num`.
- `field > num`: the field is greater than `num`.
- `field >= num`: the field is greater than or equal to `num`.
- `field = num`: the field is equal to `num`.
- `field != num`: the field is not equal to `num`.

The `field` must appear on the _left-hand side_ of the operator. We also support a compound expression syntax.

- `num < field < num` (either `<` could be `<=`)
- `num > field > num` (either `>` could be `>=`)

Note that you can't do other compound expressions like `num < field > num`. If we encounter any kind of invalid expression, we treat the whole thing as plain text. So the above is just 5 words.

### Querying boolean fields

- `is:field`: the field is `true`.
- `not:field`: the field is `false`. The same as `NOT is:field`.

### Querying set fields

- `field:has value`: the field contains `value`.
- `field:has-all-of value1, value2, ..., valueN`: the field contains all of the values (i.e. the field is a superset of the given values).
- `field:has-any-of value1, value2, ..., valueN`: the field contains any of the values (i.e. the field has an intersection with the given values).
- `field:all-in value1, value2, ..., valueN`: the field is a subset of the given values.

### Querying text

- `field:contains value`: the field contains `value` as any substring. Case-insensitive by normalizing both the field value and the `value` to lower case.
- `field:contains-words value`: the field contains `value` as whole words. For example, "photography" contains "graph" but doesn't contain it as a whole word. Case-insensitive by normalizing both the field value and the `value` to lower case.
- `field:matches value`: the field matches `value` where `value` is a regex pattern. The regex is compiled with the `u` and `i` flags.

For text operations specifically, we have a special field name `*`, which should cause it to match all fields that contain text.

Also, any token that does not belong to a query is implicitly part of `*:contains`. For example, `Hello world` as a query is the same as `*:contains Hello *:contains world`.

</TextComponent>
</div>
